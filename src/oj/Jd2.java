package oj;

/**
 * 有n位乘客乘坐一列列车，列车一共会依次经过105个站点，从1到105编号。
 *
 * 我们已知每一位乘客的上车站点和下车站点，但是不知道这些乘客的订票顺序。
 *
 * 当一位乘客订票时，他会在当前还空余的座位中选择一个他喜欢的位置，但是我们不知道乘客的喜好，所有他具体订哪个位置我们是不知道的。
 *
 * 现在你需要计算列车最少需要安排多少座位，可以使得无论乘客的订票情况和顺序是怎么样的，所有乘客都有座位可以坐。
 *
 * 举个例子，有三位乘客：
 *
 * A：1→2
 *
 * B：2→3
 *
 * C：1→3
 *
 * 若订票顺序是A, C, B，那么只需要两个座位就一定能满足。当A订票时，他会选择一个座位，当C订票时，可用座位只剩下一个，他会订这个剩余的座位，当B订票时，可用座位也只有一个，他会订这个座位(即最开始A的那个座位)；
 *
 * 若订票顺序是A, B, C，那么有可能会需要三个座位，A订了一个座位，B订了与A不同的座位，此时C来订票时他只能订第三个座位。
 *
 * 所以对于这组例子，答案是3。
 *
 * 输入
 * 第一行包含一个整数n，表示乘客的数量。
 *
 * 1 <= n <= 1000
 *
 * 接下来n行每行包含两个整数si，ti，表示第i位乘客的上车站点和下车站点。
 *
 * 1 <= si < ti <= 105
 */

//每个人只需要看看自己在车上的时间内，会看到几个人，必须给他们安排不同的座位,记录最多看到的人数。如果由于前边订票的中途下车，
//后续订票的人抢了我的座位，我就必须再加一个
public class Jd2 {

    private static int getNumbers(int[][] users) {
        int max = 1;
        for(int i = 0; i < users.length; i++) {
            int ans = 1;
            // 开始的站点
            int start = users[i][0];
            // 结束的站点
            int end = users[i][1];
            for(int j = 0; j < i; j++) {
                // 存在覆盖区间
                if(!(end <= users[j][0] || start >= users[j][1])) {
                    ans++;
                }
            }
            max = Math.max(max, ans);
        }
        return max;
    }
}
